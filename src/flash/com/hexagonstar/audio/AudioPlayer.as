/* * hexagonlib - Multi-Purpose ActionScript 3 Library. *       __    __ *    __/  \__/  \__    __ *   /  \__/HEXAGON \__/  \ *   \__/  \__/  LIBRARY _/ *            \__/  \__/ * * Licensed under the MIT License *  * Permission is hereby granted, free of charge, to any person obtaining a copy of * this software and associated documentation files (the "Software"), to deal in * the Software without restriction, including without limitation the rights to * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of * the Software, and to permit persons to whom the Software is furnished to do so, * subject to the following conditions: *  * The above copyright notice and this permission notice shall be included in all * copies or substantial portions of the Software. *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */package com.hexagonstar.audio{	import com.hexagonstar.motion.tween.HTween;	import com.hexagonstar.time.PreciseTimer;	import flash.errors.IOError;	import flash.events.Event;	import flash.events.EventDispatcher;	import flash.events.IOErrorEvent;	import flash.events.ProgressEvent;	import flash.events.TimerEvent;	import flash.media.Sound;	import flash.media.SoundChannel;	import flash.media.SoundLoaderContext;	import flash.media.SoundTransform;	import flash.net.URLRequest;			/**	 * An audio player than can stream in sound files and play them while they are streamed.	 */	public class AudioPlayer extends EventDispatcher	{		//-----------------------------------------------------------------------------------------		// Constants		//-----------------------------------------------------------------------------------------				/**		 * Constant that is used to dispatch events everytime a playhead update occurs.		 */		public static const PLAYHEAD_UPDATE:String = "playheadUpdate";				/**		 * Constant that is used to dispatch an event when the minimum amount of audio has		 * been loaded.		 */		public static const MINIMUM_LOADED:String = "minimumLoaded";						//-----------------------------------------------------------------------------------------		// Properties		//-----------------------------------------------------------------------------------------				/** @private */		protected var _autoPlay:Boolean = true;		/** @private */		protected var _autoRewind:Boolean = true;		/** @private */		protected var _checkPolicyFile:Boolean = true;				/** @private */		protected var _bufferTime:int = 1000;		/** @private */		protected var _playheadUpdateInterval:int = 250;				/** @private */		protected var _source:Object;				/** @private */		protected var _sound:Sound;		/** @private */		protected var _soundTransform:SoundTransform;		/** @private */		protected var _channel:SoundChannel;		/** @private */		protected var _channelUpdateTimer:PreciseTimer;				/** @private */		protected var _isPlaying:Boolean;		/** @private */		protected var _isPaused:Boolean;		/** @private */		protected var _isBuffering:Boolean;		/** @private */		protected var _isClosing:Boolean;				/** @private */		protected var _bytesLoaded:int;		/** @private */		protected var _bytesTotal:int;				/** @private */		protected var _loadedLength:Number = 0;		/** @private */		protected var _estimatedLength:Number = 0;		/** @private */		protected var _minLoadedLength:Number = 0;		/** @private */		protected var _isMinLoadedDispatched:Boolean = false;				/** @private */		protected var _volume:Number = 0.75;		/** @private */		protected var _tempVolume:Number = 0.75;		/** @private */		protected var _pan:Number = 0;				/** @private */		protected var _playheadTime:Number = 0;		/** @private */		protected var _resumeTime:Number = 0;		/** @private */		protected var _leftPeak:Number = 0;		/** @private */		protected var _rightPeak:Number = 0;				/** @private */		protected var _metaAlbum:String = "";		/** @private */		protected var _metaArtist:String = "";		/** @private */		protected var _metaComment:String = "";		/** @private */		protected var _metaGenre:String = "";		/** @private */		protected var _metaSongName:String = "";		/** @private */		protected var _metaTrack:String = "";		/** @private */		protected var _metaYear:String = "";						//-----------------------------------------------------------------------------------------		// Constructor		//-----------------------------------------------------------------------------------------				/**		 * Creates a new AudioPlayer instance.		 * 		 * @param source the audio source for the player. This can bei either a string with		 *            the path to an audio file that is being loaded/streamed in or it can		 *            be an embedded sound asset.		 * @param autoPlay determines if audio should start playback automatically as soon		 *            as audio data is available.		 */		public function AudioPlayer(source:Object = null, autoPlay:Boolean = true)		{			super();						_autoPlay = autoPlay;			if (source) this.source = source;		}						//-----------------------------------------------------------------------------------------		// Public Methods		//-----------------------------------------------------------------------------------------				/**		 * Allows to preload the audio file before it's being played. Only		 * works with non-autoplay and if the player is not already playing/paused.		 */		public function preload():void		{			if (!_source || _autoPlay || _isPlaying || _isPaused) return;			if (!_sound) prepareSound();		}						/**		 * Plays the audio.		 * 		 * @param offset Offset in milliseconds from which the audio should be played back.		 */		public function play(offset:int = 0):void		{			if (_isPlaying || !_isPaused) stop();			if (!_source) return;			if (!_sound) prepareSound();			if (!_soundTransform) updateSoundTransform();						var isFadeIn:Boolean = false;						if (_resumeTime == 0 && offset != 0)			{				_resumeTime = offset;				_volume = 0;				isFadeIn = true;			}						cleanupChannel();			_channel = _sound.play(_resumeTime);			prepareChannel();						_isPlaying = true;			_isPaused = false;						if (isFadeIn) fadeIn();		}						/**		 * Pauses the audio player if it is playing.		 */		public function pause():void		{			if (!_isPlaying || _isPaused) return;			_resumeTime = _playheadTime;			_channel.stop();			_isPlaying = false;			_isPaused = true;		}						/**		 * Stops audio playback.		 */		public function stop():void		{			resetID3Tags();			resetLoadingInfo();						if (_channel) _channel.stop();						cleanupSound();			cleanupChannel();						_resumeTime = 0;			_isPlaying = false;			_isPaused = false;		}						/**		 * Returns a String Representation of AudioPlayer.		 * 		 * @return A String Representation of AudioPlayer.		 */		override public function toString():String		{			return "[AudioPlayer]";		}						//-----------------------------------------------------------------------------------------		// Getters & Setters		//-----------------------------------------------------------------------------------------				/**		 * Determines if audio should start playback automatically as soon as audio		 * data is available.		 */		public function get autoPlay():Boolean		{			return _autoPlay;		}		public function set autoPlay(v:Boolean):void		{			_autoPlay = v;		}						/**		 * Determines if the playhead should rewind to the start position once the audio		 * has finished playback.		 */		public function get autoRewind():Boolean		{			return _autoRewind;		}		public function set autoRewind(v:Boolean):void		{			_autoRewind = v;		}						public function get checkPolicyFile():Boolean		{			return _checkPolicyFile;		}		public function set checkPolicyFile(v:Boolean):void		{			_checkPolicyFile = v;		}						/**		 * The buffer time in milliseconds for streamed audio. The default is 1000ms.		 */		public function get bufferTime():int		{			return _bufferTime;		}		public function set bufferTime(v:int):void		{			_bufferTime = v;		}						/**		 * The interval time in milliseconds at that the 'playhead' is updated, i.e. how		 * often a PLAYHEAD_UPDATE event is being fired.		 */		public function get playheadUpdateInterval():int		{			return _playheadUpdateInterval;		}		public function set playheadUpdateInterval(v:int):void		{			_playheadUpdateInterval = v;		}						/**		 * The audio source for the player. This can bei either a string with the path		 * to an audio file that is being loaded/streamed in or it can be an embedded		 * sound asset.		 */		public function get source():Object		{			return _source;		}		public function set source(v:Object):void		{			if (_source == v) return;			stop();			_source = v;			if (_autoPlay) play();		}						/**		 * The current volume of the audio playback. Allowed range is from 0.0 to 1.0.		 */		public function get volume():Number		{			return _volume;		}		public function set volume(v:Number):void		{			_volume = (v > 1) ? 1 : (v < 0) ? 0 : v;			_tempVolume = _volume;			updateSoundTransform();		}						/**		 * The current panning of the audio playback. Allowed range is from -1.0 to 1.0.		 * A value of 0.0 means that the panning is centered.		 */		public function get pan():Number		{			return _pan;		}		public function set pan(v:Number):void		{			_pan = (v < -1) ? -1 : (v > 1) ? 1 : v;			updateSoundTransform();		}						/**		 * The current time at which the playhead is positioned.		 */		public function get playheadTime():Number		{			return Math.round(_playheadTime / 1000);		}		public function set playheadTime(v:Number):void		{			v = v * 1000;			if (_playheadTime == v) return;						var wasPaused:Boolean = _isPaused;			var wasPlaying:Boolean = _isPlaying;						pause();			_playheadTime = _resumeTime = Math.min(v, _loadedLength);			dispatchEvent(new Event(PLAYHEAD_UPDATE));						/* TODO should we throw the autoPlay into this AND? */			if (!wasPaused && wasPlaying)			{				play();			}		}						/**		 * The loaded bytes of the audio.		 */		public function get bytesLoaded():int		{			return _bytesLoaded;		}						/**		 * The total bytes of the audio.		 */		public function get bytesTotal():int		{			return _bytesTotal;		}						/**		 * The total time of the audio.		 */		public function get totalTime():Number		{			return Math.floor(_estimatedLength / 1000);		}						public function get rightPeak():Number		{			return _rightPeak;		}						public function get leftPeak():Number		{			return _leftPeak;		}						public function get isBuffering():Boolean		{			return _isBuffering;		}						public function get isPlaying():Boolean		{			return _isPlaying && !_isBuffering;		}						public function get isPaused():Boolean		{			return _isPaused;		}						public function get minLoadedLength():Number		{			return _minLoadedLength;		}		public function set minLoadedLength(v:Number):void		{			_minLoadedLength = v;		}						public function get metaYear():String		{			return _metaYear;		}						public function get metaTrack():String		{			return _metaTrack;		}						public function get metaSongName():String		{			return _metaSongName;		}						public function get metaGenre():String		{			return _metaGenre;		}						public function get metaComment():String		{			return _metaComment;		}						public function get metaArtist():String		{			return _metaArtist;		}						public function get metaAlbum():String		{			return _metaAlbum;		}						//-----------------------------------------------------------------------------------------		// Event Handlers		//-----------------------------------------------------------------------------------------				/**		 * @private		 */		protected function onLoadComplete(e:Event):void		{			dispatchEvent(e);		}				/**		 * @private		 */		protected function onID3(e:Event):void		{			try 			{				/* We don't want no nulls showing up */				_metaArtist = _sound.id3.artist || "";				_metaAlbum = _sound.id3.album || "";				_metaComment = _sound.id3.comment || "";				_metaGenre = _sound.id3.genre || "";				_metaSongName = _sound.id3.songName || "";				_metaTrack = _sound.id3.track || "";				_metaYear = _sound.id3.year || "";			}			catch (err:SecurityError) 			{ 				/* nothing too bad. We just don't have security permission to				 * see the id3 tags of the current file. */			} 						dispatchEvent(e || new Event(Event.ID3));		}				/**		 * @private		 */		protected function onLoadOpen(e:Event):void		{			dispatchEvent(e);		}				/**		 * @private		 */		protected function onIOError(e:IOErrorEvent):void		{			stop();						/* We only want to relay the event if it's being handled outside			 * as well ...  nasty runtime errors we're not interested in. */			if (hasEventListener(IOErrorEvent.IO_ERROR))			{				dispatchEvent(e);			}		}						/**		 * @private		 */		protected function onLoadProgress(e:ProgressEvent):void		{			_bytesLoaded = e.bytesLoaded;			_bytesTotal = e.bytesTotal;			_loadedLength = _sound.length;						/* _loadedLength indicates the length of the sound we have actually			 * already loaded. We use bytes total and loaded to project, more or			 * less, how long the sound will end up being. */			_estimatedLength = Math.ceil(_loadedLength / (_bytesLoaded / _bytesTotal));						if (!_isMinLoadedDispatched && _loadedLength >= _minLoadedLength)			{				_isMinLoadedDispatched = true;				dispatchEvent(new Event(MINIMUM_LOADED));			}						dispatchEvent(e);		}						/**		 * @private		 */		protected function onSoundComplete(e:Event):void		{			stop();			dispatchEvent(e);		}						/**		 * @private		 */		protected function onChannelTimerUpdate(e:TimerEvent):void		{			/* mostly used for when paused; if we don't check for updates, we could			 * dispatch PLAYHEAD_UPDATE many times without having anything new to			 * really broadcast. TODO: double check and optimize */			var broadcastChange:Boolean =			(				(_isBuffering != _sound.isBuffering)				|| (_leftPeak != _channel.leftPeak)				|| (_rightPeak != _channel.rightPeak)				|| (!_isPaused && (_playheadTime != _channel.position))            );			if (!broadcastChange) return;						_isBuffering = _sound.isBuffering;			_leftPeak = _channel.leftPeak;			_rightPeak = _channel.rightPeak;						/* This is for scrubbing while paused. */			if (!_isPaused)			{				_playheadTime = _channel.position;			}						dispatchEvent(new Event(PLAYHEAD_UPDATE));		}						//-----------------------------------------------------------------------------------------		// Private Methods		//-----------------------------------------------------------------------------------------				/**		 * @private		 */		protected function prepareSound():void		{			if (_source is String)			{				loadSound(String(_source));			}			else if (_source is Class)			{				instantiateSoundFromClass(Class(_source));			}		}						/**		 * @private		 */		protected function prepareChannel():void		{			if (!_channel) return;						_channel.soundTransform = _soundTransform;			_channel.addEventListener(Event.SOUND_COMPLETE, onSoundComplete, false, 0, true);						_channelUpdateTimer = new PreciseTimer(_playheadUpdateInterval);			_channelUpdateTimer.addEventListener(TimerEvent.TIMER, onChannelTimerUpdate,				false, 0, true);			_channelUpdateTimer.start();		}						/**		 * @private		 */		protected function loadSound(url:String):void		{			cleanupSound();			_sound = new Sound();  			attachSoundListeners();			_sound.load(new URLRequest(url), new SoundLoaderContext(_bufferTime,				_checkPolicyFile));		}						/**		 * @private		 */		protected function instantiateSoundFromClass(soundClass:Class):void		{			_sound = new soundClass() as Sound;			_loadedLength = _sound.length;			_estimatedLength = _sound.length;			_bytesTotal = _sound.bytesTotal;			_bytesLoaded = _sound.bytesLoaded;						/* Fake that we loaded everything instantaneously to force binding refresh.			 * TODO: actually send a progress event with the appropriate data. */			dispatchEvent(new ProgressEvent(ProgressEvent.PROGRESS));			/* Force id3 refresh */			onID3(null);			dispatchEvent(new Event(Event.COMPLETE));		}						/**		 * @private		 */		protected function cleanupSound():void		{			if (!_sound) return;						try 			{				_sound.close();			}			catch (e:IOError) 			{                /* Channel was not open, nothing to worry about. */			}			removeSoundListeners();			_sound = null;		}						/**		 * @private		 */		protected function cleanupChannel():void		{			if (!_channel) return;			_channel.removeEventListener(Event.SOUND_COMPLETE, onSoundComplete);			_channelUpdateTimer.stop();			_channelUpdateTimer.removeEventListener(TimerEvent.TIMER, onChannelTimerUpdate);			_channel = null;		}						/**		 * @private		 */		protected function attachSoundListeners():void		{			if (!_sound) return;			_sound.addEventListener(Event.COMPLETE, onLoadComplete, false, 0, true);			_sound.addEventListener(Event.ID3, onID3, false, 0, true);			_sound.addEventListener(Event.OPEN, onLoadOpen, false, 0, true);			_sound.addEventListener(IOErrorEvent.IO_ERROR, onIOError, false, 0, true);			_sound.addEventListener(ProgressEvent.PROGRESS, onLoadProgress, false, 0, true);		}						/**		 * @private		 */		protected function removeSoundListeners():void		{			if (!_sound) return;			_sound.removeEventListener(Event.COMPLETE, onLoadComplete);			_sound.removeEventListener(Event.ID3, onID3);			_sound.removeEventListener(Event.OPEN, onLoadOpen);			_sound.removeEventListener(IOErrorEvent.IO_ERROR, onIOError);			_sound.removeEventListener(ProgressEvent.PROGRESS, onLoadProgress);		}						/**		 * @private		 */		protected function updateSoundTransform():void		{			_soundTransform = _soundTransform || new SoundTransform();			_soundTransform.volume = volume;			_soundTransform.pan = pan;						if (_channel)			{				_channel.soundTransform = _soundTransform;			}		}						/**		 * @private		 */		protected function resetID3Tags():void		{			_metaArtist =			_metaAlbum =			_metaComment =			_metaGenre =			_metaSongName =			_metaTrack =			_metaYear = "";						dispatchEvent(new Event(Event.ID3));		}						/**		 * @private		 */		protected function resetLoadingInfo():void		{			_bytesTotal = _bytesLoaded = _estimatedLength = 0;			dispatchEvent(new ProgressEvent(ProgressEvent.PROGRESS));		}						/**		 * @private		 */		private function fadeIn():void		{			var tween:HTween = new HTween();			tween.target = this;			tween.duration = 2;			tween.setValue("volume", _tempVolume);			tween.play();		}	}}